#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{listings}
\pagenumbering{roman}
\let\myTOC\tableofcontents
\renewcommand\tableofcontents{%
\myTOC
\clearpage
\pagenumbering{arabic}
}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing onehalf
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip bigskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "basicstyle={\ttfamily},columns=fullflexible"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\align center

\series bold
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset

NANYANG TECHNOLOGICAL UNIVERSITY
\end_layout

\begin_layout Standard
\align center

\size huge
\begin_inset VSpace vfill
\end_inset

Developing of Innovative and Cool Mobile Applications on Google's Android
 Powered Devices
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\align center
Submitted in partial fulfillment of the requirements 
\begin_inset Newline newline
\end_inset

for the degree of Bachelor of Computer Engineering
\begin_inset Newline newline
\end_inset

 of Nanyang Technological University
\begin_inset VSpace vfill
\end_inset

by
\begin_inset Newline newline
\end_inset


\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\align center
Sahil Bajaj
\begin_inset Newline newline
\end_inset


\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\align center
School of Computer Engineering
\end_layout

\begin_layout Standard
\align center
2014
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section*
Abstract
\end_layout

\begin_layout Standard
Lorem ipsum dolor sit amet.
 U chebin estel amin.
 Elbereth, Gilthoniel, silivren penna miriel.
 O menel aglar elenath, na-chaered palan diriel.
\end_layout

\begin_layout Standard
We still remember, we who dwell in this far land beneath the trees, the
 starlight on the western seas.
\end_layout

\begin_layout Section*
Acknowledgements
\end_layout

\begin_layout Standard
I would like to thank the academy, the mystical pink unicorn and potatoes.
\end_layout

\begin_layout Standard
The Wheel of time turns and ages come and pass, leaving memories that become
 legend.
 Legend fades to myth and even myth is long forgotten when the age that
 gave it birth comes again.
 In one such age, an Age yet to come, an age long past; a wind rose in the
 mountains.
 The wind was not the beginning.
 There are neither beginnings nor endings to the turning of the Wheel of
 Time.
 But it was 
\emph on
a
\emph default
 beginning.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Background
\end_layout

\begin_layout Standard
lalalala
\end_layout

\begin_layout Subsection
Purpose and Scope
\end_layout

\begin_layout Standard
This purpose of this project is to design and develop an innovative mobile
 application for the Android platform.
\end_layout

\begin_layout Standard
The application scope chosen involves wireless communication between the
 Android device (mobile phone or tablet) and an Arduino device, using XBee
 (802.15.4).
\end_layout

\begin_layout Standard
The Android device needs to communicate with an Arduino board in order to
 send files or instructions wirelessly.
\end_layout

\begin_layout Standard
Since Arduino boards and Android devices support different wireless connection
 standards, an adaptor is required either for the Arduino board or the Android
 device.
 In this project, an XBee adaptor is used on the Android device so that
 the two interfaces communicate over the IEEE 802.15.4 wireless connection
 standard as shown in the figure below:
\end_layout

\begin_layout Standard
The application involves using this wireless set up of an Android device
 and Arduino device in conjunction with a server in order to perform 2-Factor
 Authentication between the devices and subsequently control or monitor
 the Arduino device from the Android application.
\end_layout

\begin_layout Subsection
Report Organisation
\end_layout

\begin_layout Standard
how this report is organised
\end_layout

\begin_layout Section
Review of Theory and Previous Work
\end_layout

\begin_layout Subsection
Previous Work
\end_layout

\begin_layout Standard
A basic application was previously created at I2R to communicate with Arduino
 boards from an Android device.
 This application is like a simpler, lighter version of the XCTU desktop
 software provided by Digi.
 It can write values to the attached XBee’s AT registers, detect Arduino
 nodes in the vicinity and sniff formatted packets broadcasted by these
 nodes.
 It cannot transmit any files to the nodes.
\end_layout

\begin_layout Subsection
Similar Applications
\end_layout

\begin_layout Standard
The following is a list of applications that do something similar to the
 proposed project; there are, however, differences in platforms, devices
 and protocols used.
\end_layout

\begin_layout Subsubsection
Nabto
\end_layout

\begin_layout Standard
Nabto aims at being a “simple solution for device vendors to offer easy
 remote access” as well as the “preferred communication” platform for the
 internet of things.
 It includes a web server interface for devices providing local and remote
 connectivity with optional central services including remote update and
 storage and logging abilities.
\end_layout

\begin_layout Standard
Supported devices include Raspberry Pi, Windows/Unix, Microchip PIC, Nabduino,
 Arduino (wired), etc.
 Nabto provides demos for these devices; however, most of them are prototypes
 using the proprietary uNabto Adapter and uNabto starter kit.
\end_layout

\begin_layout Standard
The web interface uses a custom protocol (nabto://).
 It is also available as an Android app, which is essentially a wrapper
 around the web interface.
\end_layout

\begin_layout Subsubsection
DaisyCentral and DaisyWorks Desktop
\end_layout

\begin_layout Standard
DaisyWorks, Inc.
 manufactures a device called the ‘Daisy’, an Arduino derivative with radio
 jacks, IrDA, SD card slots, and Bluetooth.
 This device can be used in conjunction with components called Daisy Petals
 – small, modular devices that add extra functionality like moisture/light/tempe
rature sensors, USB interface, and so on.
\end_layout

\begin_layout Standard
In order to communicate with the Daisy, there are two main applications
 provided: DaisyCentral, and DaisyWorks Desktop.
 The former is an Android application while the latter is a cross-platform
 desktop application, working on Windows, OSX (not tested on Lion and Mountain
 Lion), and Linux (Debian).
 These applications can wireless connect with the Bluetooth-enabled Daisy
 device and can be used to toggle switches or to update the firmware on
 the device.
\end_layout

\begin_layout Standard
In addition to the DaisyCentral Android application, DaisyWorks also provides
 two more Android applications: Daisy On/Off App, and Daisy Hygro Petal
 App.
\end_layout

\begin_layout Standard
These applications integrate with Petals to provide specific functionality
 (such as showing the status of the sensors in the case of the Daisy Hygro
 Petal App).
 DaisyWorks also has an App Store, inviting developers to create and submit
 applications written for the Daisy devices to the store so that other users
 may benefit from them.
 Currently, the App Store consists of 9 applications, all written by DaisyWorks.
\end_layout

\begin_layout Section
Resources and Costing
\end_layout

\begin_layout Standard
hello there
\end_layout

\begin_layout Section
Project Schedule
\end_layout

\begin_layout Standard
discuss something here
\end_layout

\begin_layout Section
Design
\end_layout

\begin_layout Standard
This section describes the design of the entire system: the Android application
 as well as its dependent components.
 The overall system architecture is explained, followed by a description
 of the entity relationships, use cases, and the user interface.
 Since the two-factor authentication backed security is a main component
 of the design of the system, a detailed description of its flow has been
 provided.
\end_layout

\begin_layout Subsection
System architecture
\end_layout

\begin_layout Standard
The entire system consists of four components: an Android mobile device,
 an Arduino sensor node, a server backend, and a local personal computer
 that polls the server.
\end_layout

\begin_layout Standard
The Android and Arduino devices, and the local machine have XBee modules
 attached to them to facilitate wireless communication using the 802.15.4
 protocol.
 In the case of the Android device and local machine, the XBee modules are
 connected via USB using an XBee Explorer Dongle.
 For the Arduino device, the XBee is connected using an XBee Shield.
\end_layout

\begin_layout Standard
The 
\series bold
Android mobile device
\series default
 contains is the main user-facing application, allowing communication with
 the nodes.
 It allows the user to log in, retrieve the authentication key for a particular
 node, establish a communication protocol with a node secured by two-factor
 authentication, and transfer files to the node.
\end_layout

\begin_layout Standard
The 
\series bold
Arduino node
\series default
 waits for requests from the mobile device and accordingly responds to the
 encrypted challenges and authentication requests.
\end_layout

\begin_layout Standard
The 
\series bold
server
\series default
 backend coordinates the two-factor authentication requests, generating
 tokens to be sent to the mobile device and specified node.
 It also stores the credentials and details of the various users who log
 in via the Android application.
\end_layout

\begin_layout Standard
The 
\series bold
local machine
\series default
 runs a small Java program that periodically polls the server, checking
 for any outstanding transmission requests.
 If it finds any, it relays these to the respective nodes via the XBee module
 attached to it.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:architecture"

\end_inset

 shows how the various components interact with each other.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/architecture-design.png
	lyxscale 25
	width 100line%
	groupId CenterFull

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
High-level architecture diagram
\begin_inset CommandInset label
LatexCommand label
name "fig:architecture"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Two-Factor Authentication design
\end_layout

\begin_layout Standard
One of the main features of this application is security via two-factor
 authentication.
 This is enabled through an encrypted challenge request-response mechanism
 between the mobile device and the sensor node, followed by a comparison
 of authentication tokens sent to each device separately by the server.
\end_layout

\begin_layout Standard
The two-factor authentication flow has been designed with the following
 security features in mind:
\end_layout

\begin_layout Enumerate
The communication between the mobile device (Android) and the node (Arduino)
 uses 256-bit AES encryption
\end_layout

\begin_layout Enumerate
The server is secured using the HTTPS protocol over TLS 1.2
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:twofaflow"

\end_inset

 shows an overview of how this communication takes place.
 For the purpose of simplification, the server and local machine are shown
 as one component, since the purpose of the local machine is to relay messages
 back and forth between the server and the Arduino node.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/2fa-flow.png
	lyxscale 25
	width 100line%
	groupId CenterFull

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Two-factor authentication flow diagram
\begin_inset CommandInset label
LatexCommand label
name "fig:twofaflow"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following steps describe the two-factor authentication process in greater
 detail:
\end_layout

\begin_layout Enumerate
User logs from their Android device to the backend server using their username/p
assword credentials
\end_layout

\begin_layout Enumerate
If login is successful, these credentials are stored by the application
\end_layout

\begin_layout Enumerate
User sends requests the server for the authentication key of the node it
 wants to communicate with
\end_layout

\begin_layout Enumerate
The server responds with the key if the node is valid
\end_layout

\begin_layout Enumerate
The mobile device sends a request to the node, encrypted with the key it
 received from the server
\end_layout

\begin_layout Enumerate
The node checks the request; if it is valid it requests the mobile device
 for the auth token
\end_layout

\begin_layout Enumerate
At the same time, the node informs the server that a 2FA request has been
 initiated by the mobile device
\end_layout

\begin_layout Enumerate
The mobile device also informs the server of the same
\end_layout

\begin_layout Enumerate
The server verifies this information and sends a 2FA code to both the node
 and the user
\end_layout

\begin_layout Enumerate
The user enters to 2FA code using the Android app
\end_layout

\begin_layout Enumerate
The mobile device sends this code to the Arduino node, which verifies it
 and sends a confirmation
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:tfasequence"

\end_inset

 shows the sequence diagram for this procedure.
 After the authentication succeeds, the user may interact with the sensor
 node, e.g., by sending files to it for the purpose of this project.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/2fa-sequence.png
	lyxscale 25
	width 100line%
	groupId CenterFull

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Sequence of the two-factor authentication process
\begin_inset CommandInset label
LatexCommand label
name "fig:tfasequence"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Database Entity Relationship
\end_layout

\begin_layout Standard
The backend server performs various functions such as validating user logins,
 responding to requests for authentication keys for the various sensor nodes,
 generating authentication tokens, and coordinating the requests between
 the mobile devices and sensor nodes.
 To achieve these tasks, it needs to store various data, which it does in
 the form of a simple database.
\end_layout

\begin_layout Standard
The database contains the following entities and fields:
\end_layout

\begin_layout Enumerate

\series bold
Users
\series default
: A collection of the users registered in the system.
 It contains fields such as usernames, passwords, and email addresses.
 It is primarily used when a user wishes to log in to the system.
\end_layout

\begin_layout Enumerate

\series bold
Nodes
\series default
: A list of the nodes and their authentication keys.
\end_layout

\begin_layout Enumerate

\series bold
Transmissions
\series default
: Whenever the server is asked to generate a new two-factor authentication
 token, it creates one and sends it to the mobile device.
 It also needs to send the same token to the sensor node so that the node
 may compare the token it receives from the mobile device.
 In order to do this, it stores the generated token along with the node
 identifier, an identifier for the device that requested the token, and
 the time of the request in this collection.
 This data is then requested by the local machine periodically and any outstandi
ng requests are transmitted to the respective sensor nodes.
\end_layout

\begin_layout Standard
The 
\series bold
nodes
\series default
 and 
\series bold
transmissions
\series default
 entities are related: a node may contain multiple transmission requests,
 however a single transmission request can be for only one particular node.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/er-diagram.png
	lyxscale 25
	width 100line%
	groupId CenterFull

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Database ER diagram
\begin_inset CommandInset label
LatexCommand label
name "fig:Database-ER-diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Database-ER-diagram"

\end_inset

 shows this entity relationship in the form of a diagram.
\end_layout

\begin_layout Subsection
Use Cases
\end_layout

\begin_layout Subsubsection
Android application use cases
\end_layout

\begin_layout Standard
The Android application is the main user-facing application.
 It interacts with the sensor node directly, as well as with the help of
 the backend server.
\end_layout

\begin_layout Standard
Users of this system may use the Android application to perform several
 tasks, ranging from logging in to sending files.
 These use cases of the system are described below.
\end_layout

\begin_layout Standard
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\shape smallcaps
Title
\shape default
: Use Case #1: User wants to log in to the system
\end_layout

\begin_layout Plain Layout

\shape smallcaps
Main success scenario:
\shape default
 
\end_layout

\begin_layout Plain Layout

\emph on
User
\emph default
: Enters their username and password, and presses the submit button.
 
\end_layout

\begin_layout Plain Layout

\emph on
System
\emph default
: Verifies the credentials entered by the user (by checking the server database)
, and opens the next activity if they are correct.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\shape smallcaps
Title
\shape default
: Use Case #2: User wants to log out from the system 
\end_layout

\begin_layout Plain Layout

\shape smallcaps
Main success scenario: 
\end_layout

\begin_layout Plain Layout

\emph on
User
\emph default
: Presses the 'log out' button.
 
\end_layout

\begin_layout Plain Layout

\emph on
System
\emph default
: Clears the user's history and stored credentials.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\shape smallcaps
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\shape smallcaps
Title
\shape default
: Use Case #3: User wants to connect to a sensor node 
\end_layout

\begin_layout Plain Layout

\shape smallcaps
Main success scenario: 
\end_layout

\begin_layout Plain Layout

\series bold
Step 1: 
\end_layout

\begin_layout Plain Layout

\emph on
User
\emph default
: Chooses a particular sensor node to connect to.
 
\end_layout

\begin_layout Plain Layout

\emph on
System
\emph default
: Sends a request to the server for that node's authentication key.
 
\end_layout

\begin_layout Plain Layout

\series bold
Step 2: 
\end_layout

\begin_layout Plain Layout

\emph on
System
\emph default
: Using the authentication key, sends an encrypted request to the node for
 connecting to it.
\end_layout

\begin_layout Plain Layout

\series bold
Step 3: 
\end_layout

\begin_layout Plain Layout

\emph on
System
\emph default
: Once the node responds in the affirmative, requests the server for a two-facto
r authentication token for the node.
\end_layout

\begin_layout Plain Layout

\series bold
Step 4: 
\end_layout

\begin_layout Plain Layout

\emph on
User
\emph default
: Enters the authentication token received.
 
\end_layout

\begin_layout Plain Layout

\emph on
System
\emph default
: Sends an encrypted request to the sensor node with the authentication
 token, and waits for the node to respond with an 'all clear' message.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\shape smallcaps
Title
\shape default
: Use Case #4: User wants to send a file to the node 
\end_layout

\begin_layout Plain Layout

\shape smallcaps
Main success scenario: 
\end_layout

\begin_layout Plain Layout

\emph on
User
\emph default
: Chooses a particular file to send to the sensor node.
 
\end_layout

\begin_layout Plain Layout

\emph on
System
\emph default
: Transmits the file (breaking it into multiple packets if necessary) using
 the node's authentication key.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Use-case-diagram"

\end_inset

 shows these use cases and their dependencies in the form of a use case
 diagram.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/use-case.png
	lyxscale 25
	width 100line%
	groupId CenterFull

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Use case diagram for the Android application
\begin_inset CommandInset label
LatexCommand label
name "fig:Use-case-diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Server use cases
\end_layout

\begin_layout Standard
The server, which performs tasks such as validating user logins, generating
 authentication tokens, and so on, also provides an interface for creating
 new users, updating user details, and adding new sensor nodes with their
 authentication keys.
 These tasks are described below.
\end_layout

\begin_layout Standard
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\shape smallcaps
Title
\shape default
: Use Case #1: Create a new user 
\end_layout

\begin_layout Plain Layout

\shape smallcaps
Main success scenario: 
\end_layout

\begin_layout Plain Layout

\emph on
User
\emph default
: Provides details of new user to be created.
 
\end_layout

\begin_layout Plain Layout

\emph on
System
\emph default
: Adds a new user to the database.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\shape smallcaps
Title
\shape default
: Use Case #2: Update a user's details 
\end_layout

\begin_layout Plain Layout

\shape smallcaps
Main success scenario: 
\end_layout

\begin_layout Plain Layout

\emph on
User
\emph default
: Provide fields and values to be updated.
 
\end_layout

\begin_layout Plain Layout

\emph on
System
\emph default
: Update specified user.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout

\shape smallcaps
Title
\shape default
: Use Case #3: Add a new sensor node
\end_layout

\begin_layout Plain Layout

\shape smallcaps
Main success scenario: 
\end_layout

\begin_layout Plain Layout

\emph on
User
\emph default
: Provide details of the new sensor node.
 
\end_layout

\begin_layout Plain Layout

\emph on
System
\emph default
: Add sensor node to the database with the specified details.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:server-use-cases"

\end_inset

 is a use case diagram for these use cases.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/server-use-cases.png
	lyxscale 25
	width 100line%
	groupId CenterFull

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Use case diagram for the backend server
\begin_inset CommandInset label
LatexCommand label
name "fig:server-use-cases"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
User Interface Flow
\end_layout

\begin_layout Standard
For the Android application, the user experience focuses on providing a
 simple interface to the user, with each screen focusing on a single task,
 thus avoiding any confusion.
\end_layout

\begin_layout Standard
Some of the ideas incorporated in the user interface include:
\end_layout

\begin_layout Enumerate
Straightforward navigation
\end_layout

\begin_layout Enumerate
Clear visual and textual feedback
\end_layout

\begin_layout Enumerate
Following design conventions
\end_layout

\begin_layout Enumerate
Clutter-free design
\end_layout

\begin_layout Standard
The design of the interface for this application is influenced by ideas
 described in Steve Krug's book, 
\emph on
Don't Make Me Think
\emph default
.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:User-interface-flow"

\end_inset

 shows the basic UI flow for the Android application.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/ui-flow.png
	lyxscale 25
	width 100line%
	groupId CenterFull

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
User interface flow diagram
\begin_inset CommandInset label
LatexCommand label
name "fig:User-interface-flow"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When the user opens the application for the first time, they are greeted
 by a login form.
 If the login credentials entered by the user are incorrect, a message is
 displayed asking them to try again.
 If successful, the user is then asked to choose a particular node to connect
 to.
 Once the user makes their choice, they are asked to enter the two-factor
 authentication token received by them.
 Upon entering a correct authentication token, the user is connected to
 the node and can transfer files to it.
 The user is presented with a list of files.
 On choosing a particular file, the file transfer process is initiated,
 with visual feedback showing the status of the file transfer.
\end_layout

\begin_layout Subsection
Data Flow diagrams
\end_layout

\begin_layout Standard
Flow of data between stuff
\end_layout

\begin_layout Section
Implementation Details
\end_layout

\begin_layout Standard
how it is implemented, technologies used
\end_layout

\begin_layout Subsection
Software Used
\end_layout

\begin_layout Standard
IntelliJ IDEA 13
\end_layout

\begin_layout Standard
Sublime Text 3
\end_layout

\begin_layout Standard
Arduino IDE
\end_layout

\begin_layout Standard
xctu-ng
\end_layout

\begin_layout Subsection
Server
\end_layout

\begin_layout Standard
As mentioned in the design section, the backend server coordinates the two-facto
r authentication requests, generating tokens to be sent to the mobile device
 and specified node.
 It also provides functionality for authenticating users.
 The following subsections describe the various components of the server
 solution stack.
\end_layout

\begin_layout Subsubsection
Server stack description
\end_layout

\begin_layout Standard
The server stack used in this project consists of three main components:
 the software platform (Node.js), a web application framework (Express),
 and a database (MongoDB).
\end_layout

\begin_layout Paragraph
Node.js
\end_layout

\begin_layout Standard
Node.js forms the base of the server stack.
 According to its website
\begin_inset Foot
status open

\begin_layout Plain Layout
nodejs.org
\end_layout

\end_inset

, 
\begin_inset Quotes eld
\end_inset

Node.js is a platform built on Chrome's JavaScript runtime for easily building
 fast, scalable network applications.
 Node.js uses an event-driven, non-blocking I/O model that makes it lightweight
 and efficient, perfect for data-intensive real-time applications that run
 across distributed devices.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
As per to the design specifications, the server mainly requires a lightweight
 API for accessing a small number of functions.
 Due to the scalable and modular nature of Node.js as well as the vast number
 of libraries available for it, it was chosen as the architecture for the
 server.
 While no complex web interface is needed for this project, adding one in
 the future is as simple as requiring one of the standard templating libraries
 such as EJS
\begin_inset Foot
status open

\begin_layout Plain Layout
Embedded JavaScript: http://embeddedjs.com/
\end_layout

\end_inset

, Handlebars
\begin_inset Foot
status open

\begin_layout Plain Layout
Handlebars.js - Minimal Templating on Steroids: http://handlebarsjs.com/
\end_layout

\end_inset

, or Jade
\begin_inset Foot
status open

\begin_layout Plain Layout
Jade - Template Engine: http://jade-lang.com/
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Node.js applications also enjoy easy deployment on cloud service providers
 such as Heroku
\begin_inset Foot
status open

\begin_layout Plain Layout
Heroku - Cloud Application Platform: https://www.heroku.com/
\end_layout

\end_inset

, although in this project the server is run locally.
\end_layout

\begin_layout Paragraph
Express
\end_layout

\begin_layout Standard
Express is a small web application framework for Node.js.
 It 
\begin_inset Quotes eld
\end_inset

provides a robust set of features
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
http://expressjs.com/
\end_layout

\end_inset

 for building small-to-large web applications (single page, multi-page,
 as well as hybrid applications).
\end_layout

\begin_layout Standard
Express is essentially a thin abstraction on top of Node.js's HTTP module
 and Connect middleware
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.senchalabs.org/connect/
\end_layout

\end_inset

.
 While not strictly required - the server API could be written in vanilla
 Node.js - it provides certain syntactic sugar and methods that are especially
 useful when developing a RESTful web interface.
\end_layout

\begin_layout Paragraph
MongoDB
\end_layout

\begin_layout Standard
As can be seen from the entity relationship diagram above, the data requirements
 for the server are fairly straightforward with no complex dependencies.
 Consequently, a fast and flexible database was chosen to serve as the data
 store for the application.
\end_layout

\begin_layout Standard
MongoDB is a non-relational NoSQL database.
 A NoSQL database 
\begin_inset Quotes eld
\end_inset

provides a mechanism for storage and retrieval of data that is modeled in
 means other than the tabular relations used in relational databases
\begin_inset Quotes erd
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
http://en.wikipedia.org/wiki/Nosql
\end_layout

\end_inset

 and such databases are usually simple in design and scale very well horizontall
y.
\end_layout

\begin_layout Standard
MongoDB is one of the most popular NoSQL databases
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.mongodb.com/mongodb-overview
\end_layout

\end_inset

, and can be thought as the de-facto choice for Node.js web applications
 because of its ease of use and features such as the JSON data model, aggregatio
n framework and JavaScript API.
\end_layout

\begin_layout Standard
Since it is a non-relational database, the traditional RDBMS concepts of
 tables, fields, and records are not really the same.
 However, in MongoDB, a 'collection' is similar to a table, and a 'document'
 inside the collection is similar to a record.
 Documents even in the same collection can have different fields, i.e., it
 is a schemaless database.
 However, it is possible to define a schema and this has been done using
 Node.js's Mongoose Object Modeling module
\begin_inset Foot
status open

\begin_layout Plain Layout
http://mongoosejs.com/
\end_layout

\end_inset

 for consistency.
\end_layout

\begin_layout Standard
Mongoose allows defining schemas, compiling them to models, and then saving
 documents based on these models.
 The listing below shows how these are implemented for the Users collection.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,xleftmargin=30pt}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C,]{code/mongoose.js}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Security
\end_layout

\begin_layout Standard
The Express web application creates an HTTPS server, which runs on port
 8000 by default.
\end_layout

\begin_layout Standard
This secure communication channel makes use of the TLS 1.2 protocol.
 TLS (or Transport Layer Security) is the successor to the SSL protocol,
 and uses public-key cryptography to encrypt messages.
 In public-key cryptography, each peer has two keys - a public key and a
 private key.
 In the case of TLS, the public key is known as a certificate.
 For the scope of this project, a self-signed certificate has been used.
\end_layout

\begin_layout Standard
The 
\family typewriter
openssl
\family default
 toolkit
\begin_inset Foot
status open

\begin_layout Plain Layout
https://www.openssl.org/
\end_layout

\end_inset

 has been used to generate the required keys and certificates.
 The procedure for generating these is detailed below: 
\end_layout

\begin_layout Enumerate
Generate a private key.
 Using the command below, a 2048-bit key is generated and written to the
 file 
\family typewriter
private-key.pem
\family default
.
\family typewriter

\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

openssl genrsa -out private-key.pem 2048
\end_layout

\begin_layout Enumerate
After this, a CSR (Certificate Signing Request) must be generated using
 the private key created in the previous step.
 This CSR can be passed on to a Certificate Authority to sign a certificate
 or may be used to self-sign a certificate, as is done in the following
 step.
 
\family typewriter

\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

openssl req -new -key private-key.pem -out csr.pem
\end_layout

\begin_layout Enumerate
Finally, generate a public certificate using the CSR and private key generated
 in the previous two steps.
 
\family typewriter

\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

openssl x509 -req -in csr.pem -signkey private-key.pem -out public-cert.pem
\end_layout

\begin_layout Standard
Once these keys have been generated, the web application must be told to
 use them.
 This can easily be done using Node.js's built-in 
\family typewriter
https
\family default
 module
\begin_inset Foot
status open

\begin_layout Plain Layout
http://nodejs.org/api/https.html
\end_layout

\end_inset

, passing in an options object containing the 
\family typewriter
key
\family default
 and 
\family typewriter
cert
\family default
 parameters.
\end_layout

\begin_layout Standard
Running the 
\family typewriter
curl
\family default
 command with headers enabled, we can see that the server is running HTTPS
 using TLS 1.2 encrypted using 256-bit encryption.
 The openssl website has a list of all the available ciphers and their descripti
ons
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.openssl.org/docs/apps/ciphers.html#CIPHER_LIST_FORMAT
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Box Doublebox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

\family typewriter
$ curl -kv --user admin:admin https://spinningarrow.no-ip.biz:8000/
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

\family typewriter
* Trying 172.22.109.112...
 
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

\family typewriter
* Connected to spinningarrow.no-ip.biz (172.22.109.112) port 8000 (#0) 
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

\family typewriter
* TLS 1.2 connection using TLS_RSA_WITH_AES_256_CBC_SHA256 
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

\family typewriter
* Server certificate: spinningarrow.no-ip.biz 
\end_layout

\begin_layout Plain Layout
\paragraph_spacing single
\noindent

\family typewriter
* Server auth using Basic with user 'admin'
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
User Authentication
\end_layout

\begin_layout Standard
The server uses HTTP Basic Authentication to verify the user's credentials.
 In this method, the credentials are Base64 encoded (but not encrypted or
 hashed), which is one reason why the HTTPS security is essential for the
 server's communication process.
\end_layout

\begin_layout Standard
The Node.js Passport module
\begin_inset Foot
status open

\begin_layout Plain Layout
http://passportjs.org/
\end_layout

\end_inset

 has been used.
 It is an authentication middleware that can simply be dropped into any
 Express web application.
 It supports a variety of authentication mechanisms from Basic and Digest
 authentication, to OpenID, Facebook, and Google logins.
\end_layout

\begin_layout Standard
When Passport is invoked, it reads the Users collection from the database,
 comparing the provided username with the password to see if they match.
 The 
\family typewriter
passport-http
\family default

\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/jaredhanson/passport-http
\end_layout

\end_inset

 module has been used to provide Basic Authentication using Passport's BasicStra
tegy authentication strategy.
\end_layout

\begin_layout Standard
All API endpoints that need to be protected simply invoke the Passport middlewar
e using the following single line of code:
\end_layout

\begin_layout Standard

\family typewriter
passport.authenticate('basic', { session: false })
\end_layout

\begin_layout Subsubsection
REST API
\end_layout

\begin_layout Standard
The server provides a simple REST API for interacting with it.
 A RESTful HTTP API makes use of the HTTP verbs such as GET, POST, PUT and
 DELETE on various resource endpoints based on the type of action that is
 to be taken on that resource.
 This API is mainly consumed by the Android application and the polling
 module running on the local machine, but is easily extensible.
\end_layout

\begin_layout Standard
The API is secured using Basic Authentication over HTTPS.
 In keeping with the statelessness of HTTP and the nature of REST APIs,
 a username-password combination must be sent with every request.
 This is easily verified on the server using the Passport module described
 above, where every API endpoint that needs to be secured simply invokes
 the 
\family typewriter
passport.authenticate
\family default
 middleware.
\end_layout

\begin_layout Standard
The API endpoints are defined in the routes module uses by the application,
 with routes pertaining to different components (e.g., Users) separated into
 their own files.
 Express allows defining the routes with their corresponding verb using
 methods such as 
\family typewriter
app.get
\family default
 (for GET requests) and 
\family typewriter
app.post
\family default
 (for POST requests).
 The 
\family typewriter
request
\family default
 and 
\family typewriter
response
\family default
 objects are passed into the callback method.
\end_layout

\begin_layout Standard
Some of the API endpoints are described below:
\end_layout

\begin_layout Enumerate

\family typewriter
GET /keys/nodeId
\family default

\begin_inset Newline newline
\end_inset

This endpoint retrieves the AES encryption key for the specified node by
 looking at the Nodes collection.
 For instance, to get the key for node 1, a GET request would be made to
 /
\family typewriter
keys/1
\family default
.
\end_layout

\begin_layout Enumerate

\family typewriter
GET /token-requests
\family default

\begin_inset Newline newline
\end_inset

This endpoint gets the last token request created for each node.
 It uses MongoDB's aggregation mechanism (similar to an SQL 
\family typewriter
GROUP BY
\family default
 query) and a promises library that ensures that the function returns only
 after the query has completed.
\end_layout

\begin_layout Enumerate

\family typewriter
POST /token-requests
\family default

\begin_inset Newline newline
\end_inset

When passed a Node ID and Device ID, this endpoint creates a new token for
 the specified node, as detailed in the 'Token Generation' sub-section.
\end_layout

\begin_layout Standard
Other endpoints include 
\family typewriter
/login
\family default
 for verifying that a specified username-password combination is valid,
 
\family typewriter
/users
\family default
 for creating new users, and 
\family typewriter
/nodes
\family default
 for creating new nodes.
\end_layout

\begin_layout Standard
All endpoints return JSON results with appropriate HTTP status codes.
\end_layout

\begin_layout Subsubsection
Token Generation
\end_layout

\begin_layout Standard
Generating the two-factor authentication tokens involves a number of steps.
\end_layout

\begin_layout Standard
The process is initiated when a POST request is made to the '
\family typewriter
/token-requests
\family default
' endpoint, providing the IDs of the node and device for which the token
 is to be generated.
 Since this is an authenticated endpoint, a username-password combination
 is also provided.
 Using this, the user's email address is looked up so that the generated
 token may be emailed to them.
\end_layout

\begin_layout Standard
Once the user is found, a new document is inserted into the 
\series bold
Transmissions
\series default
 collection, containing the details of the request and a randomly-generated
 six-digit authentication token.
 Following this, an email is sent to the user containing the two-factor
 authentication token.
\end_layout

\begin_layout Standard
Email is handled by the Nodemailer module
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.nodemailer.com/
\end_layout

\end_inset

.
 The module supports SMTP, sendmail, Amazon SES, and custom mail methods.
 In this project, SMTP using Gmail has been used.
 A new Gmail account 
\family typewriter
xbee2fa@gmail.com
\family default
 was created.
 The email address and password are passed to nodemailer using environment
 variables, which must be loaded into the shell before the server is started.
 The module uses SMTP to send an HTML email via Gmail; for clients that
 don't support HTML emails, Nodemailer handily also converts the HTML to
 text via the 
\family typewriter
generateTextFromHTML
\family default
 option.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:nodemailer"

\end_inset

 shows an example of an email sent to a user containing the generated two-factor
 authentication code.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/nodemailer.png
	lyxscale 25
	width 100line%
	groupId CenterFull

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
An example two-factor authentication code emailed to a user
\begin_inset CommandInset label
LatexCommand label
name "fig:nodemailer"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Android application
\end_layout

\begin_layout Standard
Here be dragons.
\end_layout

\begin_layout Subsubsection
XBee Library
\end_layout

\begin_layout Standard
The Android application makes use of the XBEE_I2R library developed previously.
 It builds upon the components in this library and the supporting SDXbeta
 application.
\end_layout

\begin_layout Standard
The XBEE_I2R project is chiefly an adaptation of the 
\emph on
xbee-api
\emph default
 Java library by Andrew Rapp
\begin_inset Foot
status open

\begin_layout Plain Layout
https://code.google.com/p/xbee-api/
\end_layout

\end_inset

 to make it work on the Android platform.
\end_layout

\begin_layout Standard
xbee-api is a Java API for communication with XBee radio modules in API
 mode.
 It is compatible with Windows, OS X, as well as Linux.
 It can transmit and receive a wide range of packets including but not limited
 to AT commands, 16- and 64-bit addressed TX and RX, status responses and
 so on.
\end_layout

\begin_layout Standard
XBEE_I2R uses the Android Java D2XX driver [http://www.ftdichip.com/Drivers/D2XX.ht
m] to send and receive data via USB to the XBee radio, converting the the
 serial transmissions required by the XBee into the USB signals that can
 be read by the Android device.
 The XBee radio is attached to an XBee Explorer connected via mini-USB to
 the Android device.
 The Android device used must support USB OTG (on-the-go) for this to work,
 which is supported by Android versions 3.1 and newer
\begin_inset Foot
status open

\begin_layout Plain Layout
http://developer.android.com/guide/topics/connectivity/usb/host.html
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
This project contains several classes, most of which are imported from the
 xbee-api library.
 The functions of the relevant extra classes is as follows:
\end_layout

\begin_layout Enumerate
The 
\family typewriter
InitializeDevice
\family default
 class is used to initialise the FTDI device, configure and connect to it.
 It contains a 
\family typewriter
getDevice
\family default
 method that returns an instance of the initialised device.
 It is used by the Android activities that need to transmit data using the
 XBee.
\end_layout

\begin_layout Enumerate
The 
\family typewriter
ReadService
\family default
 class creates a background service for the Android application that checks
 for new packets in the XBee buffer and sends broadcasts according to the
 packet type.
 The intent filters of the various activities in the application filter
 these broadcasts for those packets that are relevant to them.
 This class has been modified appropriately to handle the various packets
 required by this project.
\end_layout

\begin_layout Subsubsection
Functional Implementations
\end_layout

\begin_layout Standard
details.
\end_layout

\begin_layout Subsubsection
Support Classes
\end_layout

\begin_layout Standard
This section describes the non-activity classes used in the Android application.
\end_layout

\begin_layout Paragraph
AuthServer
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/uml-authserver.png
	lyxscale 25
	width 100line%
	groupId CenterFull

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
UML class diagram showing the AuthServer class and its composite class
\begin_inset CommandInset label
LatexCommand label
name "fig:uml-authserver"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since connecting to the server is a task that needs to be performed from
 various parts of the Android application, the 
\family typewriter
AuthServer
\family default
 class is used to make the process easier.
 It defines a constant with the server URL.
 If the server will be running locally (as in the current set up), a dynamic-DNS
 based URL can be created using a service such as No-IP
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.noip.com/
\end_layout

\end_inset

 to avoid messing around with changing IP addresses.
\end_layout

\begin_layout Standard
There is one primary method in this class: 
\family typewriter
getNewHttpClient
\family default
.
 It returns an instance of Apache's 
\family typewriter
HttpClient
\family default
.
 The method can be invoked with or without passing in a 
\family typewriter
username
\family default
 and 
\family typewriter
password
\family default
; in the former case, the 
\family typewriter
HttpClient
\family default
 will be set up with the provided credentials using Basic Authentication.
\end_layout

\begin_layout Standard
Since we are using a self-signed certificate not provided by a known Certificate
 Authority, the Android application must be instructed to allow it.
 For this purpose a class that extends 
\family typewriter
SSLSocketFactory
\family default
 is created which creates a 
\family typewriter
TrustManager
\family default
 that accepts the self-signed certificate.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:uml-authserver"

\end_inset

 shows the UML class diagram for the AuthServer class.
\end_layout

\begin_layout Paragraph
SimpleCrypto
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename images/uml-simplecrypto.png
	lyxscale 25
	width 100line%
	groupId CenterFull

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
UML class diagram for the SimpleCrypto class
\begin_inset CommandInset label
LatexCommand label
name "fig:uml-simplecrypto"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This class provides methods to encrypt and decrypt strings or raw byte arrays
 using a specified cipher transformation algorithm
\begin_inset Foot
status open

\begin_layout Plain Layout
http://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html
\end_layout

\end_inset

.
 The one used here is 
\family typewriter
AES/ECB/NoPadding
\family default
.
\end_layout

\begin_layout Standard
It has an 
\family typewriter
encrypt
\family default
 method that accepts an encryption key and the clear (unencrypted) data
 and returns the data in encrypted form.
 Similarly, the 
\family typewriter
decrypt
\family default
 method accepts a key and encrypted data, returning the unencrypted data.
 Both these methods use Oracle's 
\family typewriter
Cipher
\family default
 class from the 
\family typewriter
javax.crypto
\family default
 package to perform the encryption.
\end_layout

\begin_layout Standard
SimpleCrypto also contains a couple of helper methods as follows:
\end_layout

\begin_layout Enumerate

\family typewriter
toByte
\family default

\begin_inset Newline newline
\end_inset

This method accepts a hex string (such as 
\begin_inset Quotes eld
\end_inset

FF0A
\begin_inset Quotes erd
\end_inset

) and returns a byte array corresponding to the hex string.
 For example, if the string provided is 
\begin_inset Quotes eld
\end_inset

FF0A
\begin_inset Quotes erd
\end_inset

, then the resulting byte array will be: 
\family typewriter
{ 0xFF, 0x0A }
\family default
.
\end_layout

\begin_layout Enumerate

\family typewriter
toHex
\family default

\begin_inset Newline newline
\end_inset

This method does the reverse of the previous one, i.e., a provided byte array
 is converted to a hex string.
 For example, if the byte array is 
\family typewriter
{ 0xDE, 0xAD }
\family default
, the resulting string will be 
\begin_inset Quotes eld
\end_inset

DEAD
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:uml-simplecrypto"

\end_inset

 shows the UML class diagram for the SimpleCrypto class.
\end_layout

\begin_layout Paragraph
PacketHelper
\end_layout

\begin_layout Standard
Description
\end_layout

\begin_layout Subsubsection
User Interface
\end_layout

\begin_layout Standard
details.
\end_layout

\begin_layout Subsection
Arduino application 
\end_layout

\begin_layout Standard
In Arduino parlance, a program is known as a 'sketch'.
 Sketches are created using the Arduino IDE or some other text editor and
 uploaded to the Arduino board usually over a serial USB interface.
 
\end_layout

\begin_layout Standard
The following sections describe the various components of the Arduino sketch,
 the structure of the program, and how the sketch works.
\end_layout

\begin_layout Subsubsection
XBee library
\end_layout

\begin_layout Standard
In order to communicate with the XBee radio, the Arduino application uses
 the xbee-arduino
\begin_inset Foot
status open

\begin_layout Plain Layout
https://code.google.com/p/xbee-arduino/
\end_layout

\end_inset

 library.
 This library only supports XBees configured in API mode so that it can
 take advantage of features such as ACKs, retries, packet checksums, and
 so on
\begin_inset Foot
status open

\begin_layout Plain Layout
https://code.google.com/p/xbee-api/wiki/WhyApiMode
\end_layout

\end_inset

.
 It supports most of the packet types including TX/RX (transmission/reception),
 AT command, status, and so on.
 In this project, mainly the TX and RX packet types were used.
\end_layout

\begin_layout Standard
The library uses Arduino's 
\family typewriter
Serial
\family default
 interface, which needs to be invoked with the same baud rate at which the
 XBee is configured.
 It provides an 
\family typewriter
Rx16Response
\family default
 object for receiving RX packets addressed using 16-bit addressing, and
 a 
\family typewriter
Tx16Request
\family default
 object for sending TX packets also with 16-bit addressing.
 The 
\family typewriter
TxStatusResponse
\family default
 object is used to check whether or not the packet transmission was successful.
\end_layout

\begin_layout Standard
Details on the usage of this library and its methods are described in subsequent
 sections.
\end_layout

\begin_layout Subsubsection
AES library
\end_layout

\begin_layout Standard
The Arduino sensor node transmits packets encrypted with 256-bit AES encryption,
 and decrypts received packets with the same algorithm.
 For this purpose, the ArduinoAES256 library
\begin_inset Foot
status open

\begin_layout Plain Layout
https://github.com/qistoph/ArduinoAES256
\end_layout

\end_inset

 by Chris van Marle has been used.
 It is based on a portable C implementation by Ilya Levin
\begin_inset Foot
status open

\begin_layout Plain Layout
http://www.literatecode.com/aes256
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Using this library involves the following steps:
\end_layout

\begin_layout Enumerate

\emph on
Defining an AES-256 context
\emph default
 
\begin_inset Newline newline
\end_inset


\family typewriter
aes256_context ctxt;
\end_layout

\begin_layout Enumerate

\emph on
Creating an encryption key
\emph default
 
\begin_inset Newline newline
\end_inset

Since we are using 256-bit encryption (equivalent to 32 bytes), a byte array
 of size 32 is used to store the key.
 
\begin_inset Newline newline
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

uint8_t key[] = {
\end_layout

\begin_layout Plain Layout

  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
\end_layout

\begin_layout Plain Layout

  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
\end_layout

\begin_layout Plain Layout

  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
\end_layout

\begin_layout Plain Layout

  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\emph on
Initialising the library
\emph default

\begin_inset Newline newline
\end_inset

The context and key created above are used for initialisation.
\begin_inset Newline newline
\end_inset


\family typewriter
aes256_init(&ctxt, key);
\end_layout

\begin_layout Enumerate

\emph on
Creating the data that is to be encrypted
\emph default
 
\begin_inset Newline newline
\end_inset

The AES encryption algorithm has a fixed block size of 128 bits (equivalent
 to 16 bytes), because of which the data to be encrypted _must_ have a size
 that is a multiple of 16.
 
\begin_inset Newline newline
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

uint8_t data[] = { 
\end_layout

\begin_layout Plain Layout

  0x61, 0x73, 0x64, 0x66, 0x61, 0x73, 0x64, 0x66, 
\end_layout

\begin_layout Plain Layout

  0x61, 0x73, 0x64, 0x66, 0x61, 0x73, 0x64, 0x66 
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\emph on
Encrypting the data
\emph default
 
\begin_inset Newline newline
\end_inset

For data that is larger than 16 bytes, the encryption function must be called
 repeatedly to update the data in blocks of 128 bits.
 For example, for data of size 32 bytes, the function needs to be called
 again to encrypt the remaining 16 bytes.
 
\begin_inset Newline newline
\end_inset


\family typewriter
aes256_encrypt_ecb(&ctxt, data); 
\begin_inset Newline newline
\end_inset

aes256_encrypt_ecb(&ctxt, data+16);
\end_layout

\begin_layout Enumerate

\emph on
Decrypting the data
\emph default
 
\begin_inset Newline newline
\end_inset

Similar to the encryption procedure, if the data has a size greater than
 16 bytes, the function must be called again.
 
\begin_inset Newline newline
\end_inset


\family typewriter
aes256_decrypt_ecb(&ctxt, data);
\begin_inset Newline newline
\end_inset

aes256_decrypt_ecb(&ctxt, data + 16);
\end_layout

\begin_layout Enumerate

\emph on
Releasing the context
\emph default
 
\begin_inset Newline newline
\end_inset

Finally, the context created in the first step is released.
 
\begin_inset Newline newline
\end_inset


\family typewriter
aes256_done(&ctxt);
\end_layout

\begin_layout Standard
The last step is not used in this project since the encryption and decryption
 is done in Arduino's 
\family typewriter
loop()
\family default
 function as described in the following section.
\end_layout

\begin_layout Subsubsection
Program structure
\end_layout

\begin_layout Standard
Every Arduino sketch must contain two functions: 
\family typewriter
setup()
\family default
 and 
\family typewriter
loop()
\family default

\begin_inset Foot
status open

\begin_layout Plain Layout
http://arduino.cc/en/Tutorial/BareMinimum
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The 
\family typewriter
setup
\family default
 function is called the very first time the sketch starts, which is when
 it is loaded on to the Arduino board or when the board is reset.
 Library initialisation procedures, and setting pin modes is done in this
 function.
\end_layout

\begin_layout Standard
The 
\family typewriter
loop
\family default
 function runs after setup completes, and runs repeatedly until the board
 is reset or powered down.
 The code in the 
\family typewriter
loop
\family default
 function forms the main basis of the Arduino sketch.
\end_layout

\begin_layout Standard
The code for the Arduino sketch can be broken down into three different
 sections, each of which is described below.
\end_layout

\begin_layout Paragraph

\shape smallcaps
Initialisation
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The initialisation phase occurs before the 
\family typewriter
setup
\family default
 function runs, and is used to define certain variables and create objects.
\end_layout

\begin_layout Subparagraph
Sensor node-specific configuration
\end_layout

\begin_layout Standard
Every sensor node must have a unique ID, and must also have its own 256-bit
 AES encryption key.
 These are set using the 
\family typewriter
nodeId
\family default
 and 
\family typewriter
key
\family default
 byte arrays, and should be modified when the sketch is installed on a new
 node.
\end_layout

\begin_layout Subparagraph
XBee configuration
\end_layout

\begin_layout Standard
Objects are created to interact with the XBee module.
 These include instances of 
\family typewriter
XBee
\family default
, 
\family typewriter
XBeeResponse
\family default
, 
\family typewriter
Rx16Response
\family default
, 
\family typewriter
Tx16Request
\family default
, and 
\family typewriter
TxStatusResponse
\family default
.
\end_layout

\begin_layout Standard
In addition to this, byte arrays of size 32 are created to store the packets
 that are to be sent and received by the sensor node.
 
\end_layout

\begin_layout Subparagraph
AES setup
\end_layout

\begin_layout Standard
An 
\family typewriter
aes256_context
\family default
 is created, along with two byte arrays used for storing and retrieving
 cryptographic nonce values.
\end_layout

\begin_layout Paragraph

\shape smallcaps
Setup
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Two main things happen in the setup method:
\end_layout

\begin_layout Enumerate
The XBee communication is initialised at a specified baud rate (57600 in
 this project).
\end_layout

\begin_layout Enumerate
The AES library is initialised using the context created and the key chosen.
 
\end_layout

\begin_layout Paragraph

\shape smallcaps
Loop
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
As mentioned previously, the 
\family typewriter
loop
\family default
 function repeats endlessly.
 It starts by waiting to receive an RX response.
 Once it receives this packet, it attempts to decrypt it and take action
 based on the packet's contents.
 The methods described below are used to achieve the various functionality
 required of the sensor node.
\end_layout

\begin_layout Enumerate

\family typewriter
receiveAuthRequest
\family default

\begin_inset Newline newline
\end_inset

This is the main function which runs inside Arduino's 
\family typewriter
loop()
\family default
 function, waiting for a packet to be sent to the sensor node.
 If it receives such a packet, it decrypts it and then creates an appropriate
 response.
 It also stores the nonce values in the authentication request sent by the
 mobile device.
\end_layout

\begin_layout Enumerate

\family typewriter
createAuthResponsePacket
\family default

\begin_inset Newline newline
\end_inset

This function creates a packet according to the packet format described
 in the next section.
 It then encrypts the data, making it ready for transmission.
\end_layout

\begin_layout Enumerate

\family typewriter
sendAuthResponse
\family default

\begin_inset Newline newline
\end_inset

After the packet has been created by 
\family typewriter
createAuthResponsePacket
\family default
(), 
\family typewriter
sendAuthResponse()
\family default
 is called to transmit the data via the XBee.
 If the transmission is successful, the sensor node waits for the server
 to send it a two-factor authentication token.
\end_layout

\begin_layout Enumerate

\family typewriter
receiveServerToken
\family default

\begin_inset Newline newline
\end_inset

This function receives a two-factor authentication token from the server,
 relayed by the XBee attached to the local machine.
 The token is three bytes long.
 Once the token is received and stored successfully, the sensor node is
 ready to receive the two-factor authentication challenge request from the
 Android mobile device.
\end_layout

\begin_layout Enumerate

\family typewriter
receiveDeviceToken
\family default

\begin_inset Newline newline
\end_inset

After the node receives an authentication token from the server, it stores
 it for the current session.
 It then waits up to two minutes for the Android mobile device to send it
 a request containing the token the user was sent.
 It decrypts this response and verifies it.
\end_layout

\begin_layout Enumerate

\family typewriter
verifyDeviceTokenPacket
\family default

\begin_inset Newline newline
\end_inset

This function checks that the data and token sent by the Android device
 is correct.
 It compares the Node ID sent by the device with the current node ID, the
 device ID sent in the previous request, and XORs the nonces created by
 the sensor node and the one previously sent by the mobile device, and compares
 this to the value in the received packet.
 If all these tests pass, it checks if the token it received from the server
 matches the one sent by the mobile device.
\end_layout

\begin_layout Enumerate

\family typewriter
sendAuthClearedResponse
\family default

\begin_inset Newline newline
\end_inset

If the token received by the sensor node from the server matches the one
 sent by the mobile device, it sends a response to the mobile device indicating
 that the two-factor authentication was successful.
\end_layout

\begin_layout Enumerate

\family typewriter
receiveFileData
\family default

\begin_inset Newline newline
\end_inset

This function receives the file data sent by the mobile device, checking
 each packet as it is received and finally matching the file checksum to
 the one sent by the mobile device.
 If the checksums match, the file transfer is successful.
\end_layout

\begin_layout Standard
All the functions mentioned above print appropriate logs to the Serial Monitor,
 including appropriate messages when the functions succeed or fail.
\end_layout

\begin_layout Subsubsection
Packet Formats
\end_layout

\begin_layout Standard
This section details the formats of the main packets sent and received by
 the sensor node during the two-factor authentication procedure.
\end_layout

\begin_layout Enumerate
Two-factor Authentication Request Packet (sent by mobile device)

\begin_inset Newline newline
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Data
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Length
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nonce
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 bytes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Device ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 bytes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Node ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 bytes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Timestamp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Enumerate
Two-factor Authentication Response + Token Request (sent by sensor node)
\begin_inset Newline newline
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Data
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Length
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Node ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 bytes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Device ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 bytes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nonce (node)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 bytes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nonce (device)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 bytes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Timestamp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Enumerate
Two-factor Token Packet (sent by mobile device)
\begin_inset Newline newline
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Data
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Length
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Token
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 bytes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Device ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 bytes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Node ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 bytes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nonce XOR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 bytes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Timestamp
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
All packets are encrypted using AES-256 with the sensor node's encryption
 key.
\end_layout

\begin_layout Subsection
Server-Node Communicator
\end_layout

\begin_layout Subsubsection
Introduction
\end_layout

\begin_layout Standard
In order to relay messages from the server to the Arduino sensor node, a
 communication channel using XBee radios is required.
 One method by which this can be accomplished is by invoking a shell command
 or other library from the server that can communicate with a local XBee
 radio.
 However, this approach limits the server to be installed on the same machine
 as the XBee radio.
 It is also not a very robust solution due to the higher coupling.
\end_layout

\begin_layout Standard
Another approach is to have a program that communicates with the server,
 checking if any messages are to be sent or received.
 If there are, it uses an XBee radio attached to the machine it is running
 on to facilitate this communication.
\end_layout

\begin_layout Standard
The second approach was implemented in this project.
 Communication with the server can be achieved by a method of polling or
 a publish/subscribe paradigm; the former was used due to its ease of set
 up and compatibility with REST APIs.
\end_layout

\begin_layout Subsubsection
Implementation Details
\end_layout

\begin_layout Standard
The polling component is a Java program that also uses the 
\emph on
xbee-api
\emph default
 library, similar to the Android application.
 The library can be used directly by dropping in the JAR file from the download.
 However, note that for Mac OS X systems, 
\family typewriter
librxtxSerial
\family default
 may need to be recompiled to work on the platform.
\end_layout

\begin_layout Standard
The main function of this component is to poll the server every two seconds
 and check if there are any outstanding transmission requests.
 It uses the 
\emph on
Apache HTTPClient 4.3
\emph default
 library 
\begin_inset Foot
status open

\begin_layout Plain Layout
http://hc.apache.org/httpcomponents-client-ga/index.html
\end_layout

\end_inset

 to connect to the server.
 A 
\family typewriter
CredentialsProvider
\family default
 is created using the username and password credentials specified to connect
 to the server using Basic Authentication.
\end_layout

\begin_layout Standard
A GET request is made to the server to retrieve the latest token requests.
 The server responds with a JSON result, which is parsed using the 
\emph on
json-simple
\emph default
 library
\begin_inset Foot
status open

\begin_layout Plain Layout
https://code.google.com/p/json-simple/
\end_layout

\end_inset

.
 If these requests were created after the last time the server was polled
 (the timestamp of the last poll is tracked by the program), they are relayed
 to the respective sensor nodes using a TX request sent by the XBee.
\end_layout

\begin_layout Section
Testing
\end_layout

\begin_layout Standard
how it is tested
\end_layout

\begin_layout Section
Discussion
\end_layout

\begin_layout Standard
discuss
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
conclude something here
\end_layout

\begin_layout Section
Recommendations
\end_layout

\begin_layout Standard
recommend something
\end_layout

\begin_layout Section*
References
\end_layout

\begin_layout Standard
references go here
\end_layout

\end_body
\end_document
